#!/usr/bin/perl -w

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use Config::JSON;

our $VERBOSITY = 0;

use constant {
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
};

our %hdrmap_h = (
	'ID#' => 'id',
	'ATTRIBUTE_NAME'=> 'attribute',
	'FLAG' => 'flag',
	'VALUE' => 'value',
	'WORST' => 'worst',
	'THRESH' => 'thresh',
	'TYPE' => 'type',
	'UPDATED' => 'updated',
	'WHEN_FAILED' => 'when_failed',
	'RAW_VALUE' => 'raw-value'
);

sub getSmartctl{
	my $smartctl = shift;
	my $device = shift;
	my @output = `$smartctl -a $device`;
	return \@output;
}

sub readDbJSON{
	my $dbJSON = shift;
	return(Config::JSON->new($dbJSON));
}

sub checkWhichDevice{
	my $dbConfig = shift;
	my @smartctlOut = @{(shift)};
	# Fetch the model lines from smart output
	my @device = grep { /Model Family/i || /Device Model/i } @smartctlOut;

	# Fetch the device JSON hash
	my $devices_h = $dbConfig->get("Devices");
	foreach my $key (keys %$devices_h){
		# Return model strings and IDs if device is found
		foreach(@device){
			if(($_ =~ $devices_h->{$key}->{'Device'}->[0]) ||
			($_ =~ $devices_h->{$key}->{'Device'}->[1])){
				return ($devices_h->{$key}->{'Device'},$devices_h->{$key}->{'ID#'});
			}
		}
	}
}

sub parseSmartctlOut{
	my @smartctlOut = @{(shift)};
	# Check for smart value lines
	my @smartValues;
	foreach my $line (@smartctlOut) {
		if($line =~ /\d+\s+\w+\s+0x\d+\s+\d+\s+\d+\s+\d+\s+\w+/){
			$line =~ s/^\s+|\s+$//g;
			@smartValues = map { s/^\s*//; s/\s*$//; $_; } split(/\s+/,$line);
		}
	}

}

MAIN: {
	my ($smartctl, $device, $dbJSON);
	if ( !(GetOptions(
		'v|verbose' => sub { $VERBOSITY = 1 },
		'vv' => sub { $VERBOSITY = 2 },
		'vvv' => sub { $VERBOSITY = 3 },
		'h|help' => sub {displayHelp();},
		'p|path=s' => \$smartctl,
		'd|device=s' => \$device,
		'dbj|dbjson=s' => \$dbJSON
	)))	{
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	# Check smartclt tool
	if(!defined($smartctl)){
		$smartctl = "/usr/sbin/smartctl";
	}
	# The device must be present
	if(!defined($device)){
		print "Error: Valid device to check is required.\n";
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	my $output = getSmartctl($smartctl,$device);
	my $dbConfig = readDbJSON($dbJSON);
	my ($deviceName,$IDs) = checkWhichDevice($dbConfig,$output);
	parseSmartctlOut($output);
	use Data::Dumper;
	print Dumper($deviceName);
	print Dumper($IDs);

}