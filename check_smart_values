#!/usr/bin/perl -w

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use Config::JSON;

our $VERBOSITY = 0;

use constant {
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
};

our @hdrmap_a = ('ID#','ATTRIBUTE_NAME','FLAG','VALUE','WORST','THRESH',
	'TYPE','UPDATED','WHEN_FAILED','RAW_VALUE');
our @perfmap_a= ('5','194','241','242');

sub getSmartctl{
	my $smartctl = shift;
	my $device = shift;
	my @output = `$smartctl -a $device`;
	return \@output;
}

sub readDbJSON{
	my $dbJSON = shift;
	return(Config::JSON->new($dbJSON));
}

sub checkWhichDevice{
	my $dbConfig = shift;
	my @smartctlOut = @{(shift)};
	# Fetch the model lines from smart output
	my @device = grep { /Model Family/i || /Device Model/i } @smartctlOut;

	# Fetch the device JSON hash
	my $devices_h = $dbConfig->get("Devices");
	foreach my $key (keys %$devices_h){
		# Return model strings and IDs if device is found
		foreach(@device){
			if(($_ =~ $devices_h->{$key}->{'Device'}->[0]) ||
			($_ =~ $devices_h->{$key}->{'Device'}->[1])){
				return ($devices_h->{$key}->{'Device'},$devices_h->{$key}->{'ID#'},
				$devices_h->{$key}->{'Threshs'});
			}
		}
	}
}

sub parseSmartctlOut{
	my @smartctlOut = @{(shift)};
	# Check for smart value lines
	my @smartValues;
	my @splittedLine;
	foreach my $line (@smartctlOut) {
		if($line =~ /\d+\s+\w+\s+0[xX][0-9a-fA-F]+\s+\d+\s+\d+\s+\d+\s+\w+/){
			$line =~ s/^\s+|\s+$//g;
			# Split the found line, and map its elements
			# The header map defines the keys for the hash
			@splittedLine = map { s/^\s*//; s/\s*$//; $_; } split(/\s+/,$line);
			my %lineValues_h;
			for(my $i = 0; $i < @hdrmap_a; $i++){
				$lineValues_h{$hdrmap_a[$i]} = $splittedLine[$i];
			}
			push @smartValues, \%lineValues_h;
		}
		if($line =~ /(ATA Error Count)\:\s+(\d+)/){
			my %lineValues_h;
			$lineValues_h{'ATTRIBUTE_NAME'} = $1;
			$lineValues_h{'VALUE'} = $2;
			$lineValues_h{'ATTRIBUTE_NAME'} =~ s/ /_/g;
			$lineValues_h{'ID#'} = 1024;
			push @smartValues, \%lineValues_h;
		}
	}
	return \@smartValues;
}

sub checkThreshs{
	my $value = shift;
	my $pattern = shift;

	if($pattern =~ /(^[0-9]*$)/){
		if($value < 0 || $value > $1){
			return 0;
		}
	}
	if($pattern =~ /(^[0-9]*)\:$/){
		if($value < $1){
			return 0;
		}
	}
	if($pattern =~ /^\~\:([0-9]*)$/){
		if($value > $1){
			return 0;
		}
	}
	return 1;
}

sub checkSmartctl{
	my @smartValues_a = @{(shift)};
	my %IDs_h = %{(shift)};
	my %threshs_h = %{(shift)};
	my @warnings_a;
	my @criticals_a;
	my @statusLevel_a = ("OK");

	foreach my $row (@smartValues_a){
		my $ID = $row->{'ID#'};
		if(exists $IDs_h{$ID} && exists $threshs_h{$ID}){
			if(!(checkThreshs($row->{$IDs_h{$ID}},$threshs_h{$ID}->[0]))){
				$statusLevel_a[0] = 'Warning';
				push @warnings_a, $row->{'ATTRIBUTE_NAME'};
			}
			if(!(checkThreshs($row->{$IDs_h{$ID}},$threshs_h{$ID}->[1]))){
				$statusLevel_a[0] = 'Critical';
				pop @warnings_a;
				push @criticals_a, $row->{'ATTRIBUTE_NAME'};
			}
		}
	}

	push @statusLevel_a, \@warnings_a;
	push @statusLevel_a, \@criticals_a;
	return \@statusLevel_a;
}

sub getStatusString{
	my $level = shift;
	my @statusLevel_a = @{(shift)};
	my @smartValues_a = @{(shift)};
	my %IDs_h = %{(shift)};
	my @sensors_a;
	my $status_str = "";

	if($level eq "Warning"){
		@sensors_a = @{$statusLevel_a[1]};
	}
	if($level eq "Critical"){
		@sensors_a = @{$statusLevel_a[2]};
	}

	# Collect performance data of warn and crit sensors
	if($level eq "Warning" || $level eq "Critical"){
		if(@sensors_a){
			foreach my $sensor (@sensors_a){
				$status_str .= "[".$sensor." = ".$level;
				if($VERBOSITY){
					foreach my $row (@smartValues_a){
						if($row->{'ATTRIBUTE_NAME'} eq $sensor){
							my $ID = $row->{'ID#'};
							if(exists $IDs_h{$ID}){
								$status_str .= " (".$row->{$IDs_h{$ID}}.")";
							}
						}
					}
				}
				$status_str .= "]";
			}
		}
	}
	return $status_str;
}
sub getPerfString{
	my @smartValues_a = @{(shift)};
	my %IDs_h = %{(shift)};
	my %threshs_h = %{(shift)};
	my $perf_str;

	foreach my $perf (@perfmap_a){
		foreach my $row (@smartValues_a){
			if($perf eq $row->{'ID#'}){
				my $ID = $row->{'ID#'};
				my $attr_str;
				if(exists $IDs_h{$ID}){
					$attr_str = $row->{'ATTRIBUTE_NAME'}."=".$row->{$IDs_h{$ID}};
					if($perf_str){
						$attr_str = " ".$attr_str;
					}
				}
				$perf_str .= $attr_str;
				if(exists $IDs_h{$ID} && exists $threshs_h{$ID}){
					$perf_str .= ";".$threshs_h{$ID}->[0].";".$threshs_h{$ID}->[1];
				}
			}
		}
	}
	return $perf_str;
}

MAIN: {
	my ($smartctl, $device, $dbJSON, $exitCode);
	if ( !(GetOptions(
		'v|verbose' => sub { $VERBOSITY = 1 },
		'vv' => sub { $VERBOSITY = 2 },
		'vvv' => sub { $VERBOSITY = 3 },
		'h|help' => sub {displayHelp();},
		'p|path=s' => \$smartctl,
		'd|device=s' => \$device,
		'dbj|dbjson=s' => \$dbJSON
	)))	{
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	# Check smartclt tool
	if(!defined($smartctl)){
		$smartctl = "/usr/sbin/smartctl";
	}
	# The device must be present
	if(!defined($device)){
		print "Error: smartctl requires a valid device name.\n";
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	my $output = getSmartctl($smartctl,$device);
	my $dbConfig = readDbJSON($dbJSON);
	my ($deviceName,$IDs_h,$threshs_h) = checkWhichDevice($dbConfig,$output);
	my $smartValues_a = parseSmartctlOut($output);
	my $statusLevel_a = checkSmartctl($smartValues_a,$IDs_h,$threshs_h);
	$exitCode = STATE_OK;
	if($statusLevel_a->[0] eq "Critical"){
		$exitCode = STATE_CRITICAL;
	}
	if($statusLevel_a->[0] eq "Warning"){
		$exitCode = STATE_WARNING;
	}
	print $statusLevel_a->[0]." - ".$deviceName->[0]." ";
	print getStatusString("Critical",$statusLevel_a,$smartValues_a,$IDs_h);
	print getStatusString("Warning",$statusLevel_a,$smartValues_a,$IDs_h);
	my $perf_str = getPerfString($smartValues_a,$IDs_h,$threshs_h);
	if($perf_str){
		print "|".$perf_str;
	}
	exit ($exitCode);
}