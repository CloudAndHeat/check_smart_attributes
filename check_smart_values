#!/usr/bin/perl -w

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use Config::JSON;

our $VERBOSITY = 0;

use constant {
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
};

our @hdrmap_a = ('ID#','ATTRIBUTE_NAME','FLAG','VALUE','WORST','THRESH',
	'TYPE','UPDATED','WHEN_FAILED','RAW_VALUE');

sub readUCfgJSON{
	my $uCfgJSON = shift;
	return(Config::JSON->new($uCfgJSON));
}

sub readDbJSON{
	my $dbJSON = shift;
	return(Config::JSON->new($dbJSON));
}

sub getSmartctl{
	my $smartctl = shift;
	my $uCfgJSON = shift;
	#a hash of all devices with their corresponding output
	my %output_h;

	my $devices_h = $uCfgJSON->get("Devices");
	foreach my $device (keys %$devices_h){
		my @output = `$smartctl -a $device`;
		$output_h{$device} = \@output;
	}
	return \%output_h;
}

sub checkWhichDevice{
	my $dbConfig = shift;
	my $uCfgJSON = shift;
	my %smartctlOut_h = %{(shift)};;
	# Array of found device hashes
	my @devices_a;

	# Fetch the device JSON hash
	my $devices_h = $dbConfig->get("Devices");
	# Fetch the user config for the devices
	my $uCfgDevices_h = $uCfgJSON->get("Devices");

	# Check all models in the db
	foreach my $key (keys %$devices_h){
		# Check each device whose smartvalues are present
		foreach my $device (keys %smartctlOut_h){
			my @smartctlOut = @{$smartctlOut_h{$device}};
			my @device = grep { /Model Family/i || /Device Model/i } @smartctlOut;
			foreach(@device){
				# If the model matches we have found the correct db entry
				if(($_ =~ $devices_h->{$key}->{'Device'}->[0]) ||
				($_ =~ $devices_h->{$key}->{'Device'}->[1])){
					my %foundDevice_h;
					$foundDevice_h{'Path'} = $device;
					$foundDevice_h{'Device'} = $devices_h->{$key}->{'Device'};
					$foundDevice_h{'ID#'} = $devices_h->{$key}->{'ID#'};
					# Tresholds and perf variables are defined in the user cfg
					$foundDevice_h{'Threshs'} = $uCfgDevices_h->{$device}->{'Threshs'};
					$foundDevice_h{'Perfs'} = $uCfgDevices_h->{$device}->{'Perfs'};
					push @devices_a, \%foundDevice_h;
					last;
				}
			}
		}
	}
	return \@devices_a;
}

sub parseSmartctlOut{
	my %smartctlOut_h = %{(shift)};
	# A hash with the parsed smart values for all devices
	my %smartValues_h;

	foreach my $device (keys %smartctlOut_h){
		my @smartctlOut = @{$smartctlOut_h{$device}};
		# Check for smart value lines
		my @smartValues;
		my @splittedLine;
		foreach my $line (@smartctlOut) {
			if($line =~ /\d+\s+\w+\s+0[xX][0-9a-fA-F]+\s+\d+\s+\d+\s+\d+\s+\w+/){
				$line =~ s/^\s+|\s+$//g;
				# Split the found line, and map its elements
				# The header map defines the keys for the hash
				@splittedLine = map { s/^\s*//; s/\s*$//; $_; } split(/\s+/,$line);
				my %lineValues_h;
				for(my $i = 0; $i < @hdrmap_a; $i++){
					# Prepend the attribute name with the device name
					if($hdrmap_a[$i] eq 'ATTRIBUTE_NAME'){
						$device =~ /^\/dev\/(\w+)$/;
						$lineValues_h{$hdrmap_a[$i]} = $1.'_'.$splittedLine[$i];
					}
					else{
						$lineValues_h{$hdrmap_a[$i]} = $splittedLine[$i];
					}
				}
				push @smartValues, \%lineValues_h;
			}
			if($line =~ /(ATA Error Count)\:\s+(\d+)/){
				my %lineValues_h;
				$lineValues_h{'ATTRIBUTE_NAME'} = $1;
				$lineValues_h{'VALUE'} = $2;
				# Modify attribute name
				$device =~ /^\/dev\/(\w+)$/;
				$lineValues_h{'ATTRIBUTE_NAME'} =$1.'_'.$lineValues_h{'ATTRIBUTE_NAME'};
				$lineValues_h{'ATTRIBUTE_NAME'} =~ s/ /_/g;
				$lineValues_h{'ID#'} = 1024;
				push @smartValues, \%lineValues_h;
			}
		}
		$smartValues_h{$device} = \@smartValues;
	}
	return \%smartValues_h;
}

sub checkThreshs{
	my $value = shift;
	my $pattern = shift;

	if($pattern =~ /(^[0-9]*$)/){
		if($value < 0 || $value > $1){
			return 0;
		}
	}
	if($pattern =~ /(^[0-9]*)\:$/){
		if($value < $1){
			return 0;
		}
	}
	if($pattern =~ /^\~\:([0-9]*)$/){
		if($value > $1){
			return 0;
		}
	}
	return 1;
}

sub checkSmartctl{
	my %smartValues_h = %{(shift)};
	my @devices_a = @{(shift)};
	# Resulting status level variables
	my @warnings_a;
	my @criticals_a;
	my @statusLevel_a = ("OK");

	foreach my $device (@devices_a){
		# Fetch the configured variables for a device
		my %IDs_h = %{$device->{'ID#'}};
		my %threshs_h = %{$device->{'Threshs'}};
		my @smartValues_a = @{$smartValues_h{$device->{'Path'}}};
		# Check the corresponding smart values
		foreach my $row (@smartValues_a){
			my $ID = $row->{'ID#'};
			if(exists $IDs_h{$ID} && exists $threshs_h{$ID}){
				if(!(checkThreshs($row->{$IDs_h{$ID}},$threshs_h{$ID}->[0]))){
					# Don't loose the critical state
					$statusLevel_a[0] = 'Warning' unless $statusLevel_a[0] eq 'Critical';
					push @warnings_a, $row->{'ATTRIBUTE_NAME'};
				}
				if(!(checkThreshs($row->{$IDs_h{$ID}},$threshs_h{$ID}->[1]))){
					$statusLevel_a[0] = 'Critical';
					pop @warnings_a;
					push @criticals_a, $row->{'ATTRIBUTE_NAME'};
				}
			}
		}
	}

	push @statusLevel_a, \@warnings_a;
	push @statusLevel_a, \@criticals_a;
	return \@statusLevel_a;
}

sub getStatusString{
	my $level = shift;
	my @statusLevel_a = @{(shift)};
	my %smartValues_h = %{(shift)};
	my @devices_a = @{(shift)};
	# Sensors to check, warn or crit
	my @sensors_a;
	my $status_str = "";

	if($level eq "Warning"){
		@sensors_a = @{$statusLevel_a[1]};
	}
	if($level eq "Critical"){
		@sensors_a = @{$statusLevel_a[2]};
	}

	if($level eq "Warning" || $level eq "Critical"){
		if(@sensors_a){
			foreach my $sensor (@sensors_a){
				$status_str .= "[".$sensor." = ".$level;
				if($VERBOSITY){
					$sensor =~ /^([a-zA-Z]+)/;
					my $devicePath = '/dev/'.$1;
					my %IDs_h;
					my @smartValues_a;
					foreach my $device (@devices_a){
						# Fetch the configured variables for a device
						if($devicePath eq $device->{'Path'}){
							%IDs_h = %{$device->{'ID#'}};
							@smartValues_a = @{$smartValues_h{$device->{'Path'}}};
						}
					}
					foreach my $row (@smartValues_a){
						if($row->{'ATTRIBUTE_NAME'} eq $sensor){
							my $ID = $row->{'ID#'};
							if(exists $IDs_h{$ID}){
								$status_str .= " (".$row->{$IDs_h{$ID}}.")";
							}
						}
					}
				}
				$status_str .= "]";
			}
		}
	}
	return $status_str;
}
sub getPerfString{
	my %smartValues_h = %{(shift)};
	my @devices_a = @{(shift)};
	my $perf_str;

	foreach my $device (@devices_a){
		# Fetch the configured variables for a device
		my %IDs_h = %{$device->{'ID#'}};
		my %threshs_h = %{$device->{'Threshs'}};
		my @perfmap_a = @{$device->{'Perfs'}};
		my @smartValues_a = @{$smartValues_h{$device->{'Path'}}};

		foreach my $perf (@perfmap_a){
			foreach my $row (@smartValues_a){
				if($perf eq $row->{'ID#'}){
					my $ID = $row->{'ID#'};
					my $attr_str;
					if(exists $IDs_h{$ID}){
						$attr_str = $row->{'ATTRIBUTE_NAME'}."=".$row->{$IDs_h{$ID}};
						if($perf_str){
							$attr_str = " ".$attr_str;
						}
					}
					$perf_str .= $attr_str;
					if(exists $IDs_h{$ID} && exists $threshs_h{$ID}){
						$perf_str .= ";".$threshs_h{$ID}->[0].";".$threshs_h{$ID}->[1];
					}
				}
			}
		}
	}
	return $perf_str;
}

sub getVerboseString{
	my %smartValues_h = %{(shift)};
	my @devices_a = @{(shift)};
	my $verb_str;

	foreach my $device (@devices_a){
		# Fetch the configured variables for a device
		my %IDs_h = %{$device->{'ID#'}};
		my %threshs_h = %{$device->{'Threshs'}};
		my @perfmap_a = @{$device->{'Perfs'}};
		my @smartValues_a = @{$smartValues_h{$device->{'Path'}}};

		foreach my $row (@smartValues_a){
			my $ID = $row->{'ID#'};
			if(exists $IDs_h{$ID}){
				$verb_str .= "\n".$row->{'ATTRIBUTE_NAME'}."=".$row->{$IDs_h{$ID}};
				$verb_str .= " (".$IDs_h{$ID}.")";
			}
		}
	}
#	if($VERBOSITY == 3){
#		my @smartctlOut = @{(shift)};
#		$verb_str .= "\n================= \n";
#		$verb_str .= "Thresholds:\n";
#		foreach my $ID (keys %threshs_h){
#			$verb_str .= $ID.": [".$threshs_h{$ID}->[0].",".$threshs_h{$ID}->[1]."]\n";
#		}
#		$verb_str .= "================= \n";
#		$verb_str .= "Performance Value IDs:\n";
#		$verb_str .= "[@perfmap_a]\n";
#		$verb_str .= "================= \n";
#		$verb_str .= "Begin of smartctl output:\n";
#		foreach my $line (@smartctlOut){
#			$verb_str .= $line;
#		}
#	}
	return $verb_str;
}

MAIN: {
	my ($smartctl, $device, $dbJSON, $uCfgJSON, $exitCode);
	if ( !(GetOptions(
		'v|verbose' => sub { $VERBOSITY = 1 },
		'vv' => sub { $VERBOSITY = 2 },
		'vvv' => sub { $VERBOSITY = 3 },
		'h|help' => sub {displayHelp();},
		'p|path=s' => \$smartctl,
		'd|device=s' => \$device,
		'dbj|dbjson=s' => \$dbJSON,
		'ucfgj|ucfgjson=s' => \$uCfgJSON
	)))	{
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	# Check smartclt tool
	if(!defined($smartctl)){
		$smartctl = "/usr/sbin/smartctl";
	}
	# The user config must be present
	if(!defined($uCfgJSON)){
		print "Error: smartctl requires a valid user config.\n";
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	my $uCfg = readUCfgJSON($uCfgJSON);
	my $output_h = getSmartctl($smartctl,$uCfg);
	my $dbConfig = readDbJSON($dbJSON);
	my $devices_a = checkWhichDevice($dbConfig,$uCfg,$output_h);
	my $smartValues_h = parseSmartctlOut($output_h);
	my $statusLevel_a = checkSmartctl($smartValues_h,$devices_a);

	$exitCode = STATE_OK;
	if($statusLevel_a->[0] eq "Critical"){
		$exitCode = STATE_CRITICAL;
	}
	if($statusLevel_a->[0] eq "Warning"){
		$exitCode = STATE_WARNING;
	}
	# TODO Add device strings?
	print $statusLevel_a->[0]." ";
	print getStatusString("Critical",$statusLevel_a,$smartValues_h,$devices_a);
	print getStatusString("Warning",$statusLevel_a,$smartValues_h,$devices_a);
	my $perf_str = getPerfString($smartValues_h,$devices_a);
	if($perf_str){
		print "|".$perf_str;
	}
	if($VERBOSITY == 2 || $VERBOSITY == 3){
		print getVerboseString($smartValues_h,$devices_a);
	}
#	exit ($exitCode);
}